---
title: "Benthos LPI - Data Pipeline"
date: today
format: 
  html:
    theme: minty
    self-contained: true
    code-fold: true
    toc: true 
    toc-depth: 3
    toc-location: right
    html-table-processing: none
execute:
  fig-width: 10
---

```{r setup, message = F, warning = F, fig.width = 10, fig.height = 10, echo = F}
options(scipen = 999)

# Hook to format inline numeric expressions with comma separators:
knitr::knit_hooks$set(inline = function(x) {
  # For non-numeric values, just return as character
  if (!is.numeric(x)) {return(as.character(x))}
  # Format numbers with comma as big.mark, no scientific notation
  else format(x, big.mark = ",", scientific = FALSE)})

library(sf)
library(hms)
library(readxl)
library(janitor)
library(lubridate)
library(gt)
library(pointblank)
library(tidyverse)
library(bigrquery)
library(leaflet)
library(leaflet.extras)
library(ggtext)
library(PristineSeasR2)

ps_paths <- PristineSeasR2::get_drive_paths()

exp_id <- "PNG_2024"

exp_path <- file.path(ps_paths$expeditions, str_replace(exp_id, "_", "-"))

bigrquery::bq_auth(email = "marine.data.science@ngs.org")

bq_connection <- DBI::dbConnect(bigrquery::bigquery(), project = "pristine-seas")
```

This documentation outlines the end-to-end pipeline for processing benthos Line Point Intercept (LPI) survey data collected during Pristine Seas expeditions. The pipeline ingests raw field data, standardizes formats, performs taxonomy lookups, applies rigorous quality assurance/quality control (QA/QC), computes station-level summaries, and loads the clean data into the Pristine Seas Science Database in BigQuery.

## Data ingestion

### Sites

We begin by reading the UVS (Underwater Visual Survey) site information
  
```{r}
uvs_sites <- tbl(bq_connection, "uvs.sites") |> 
   filter(exp_id == "PNG_2024") |> 
   collect()

# Validate site data
cat("Sites loaded:", nrow(uvs_sites), "\n")
cat("Regions:", unique(uvs_sites$region), "\n")
cat("Subregions:", unique(uvs_sites$subregion), "\n")
```

### Fieldbooks

Next, process field observations from different divers, ensuring consistent formatting and traceability.

```{r}
read_lpi_sheet <- function(file_path, 
                           exp_id, 
                           diver,
                           section_range,
                           contacts_range) {
  
  # === 1. Parse section metadata ===
  sections_raw <- readxl::read_xlsx(path = file_path,
                                sheet = "transects",
                                range = section_range,
                                col_names = FALSE,
                                .name_repair = "minimal") |>
    t() |>
    as_tibble(.name_repair = "minimal") |>
    set_names(c("station", "section", "depth_m")) |>
    mutate(station        = str_to_upper(as.character(station)),
           section        = as.character(section),
           depth_m        = readr::parse_number(depth_m),
           site_num       = str_extract(station, "\\d+") |> str_pad(3, pad = "0"),
           ps_site_id     = paste(exp_id, "uvs", site_num, sep = "_"),
           exp_id         = exp_id,
           survey_type    = "uvs",
           method         = "lpi",
           diver          = diver,
           depth_strata   = stratify(depth_m),
           ps_station_id  = paste(ps_site_id, station_suffix(depth_strata), sep = "_"),
           section_id     = paste0(ps_station_id, "_", section)) |> 
    select(exp_id, survey_type, ps_site_id, ps_station_id, method, diver, depth_m, depth_strata, station_label = station, section, section_id)

  # Store full and valid sections separately
  full_ids   <- sections_raw$section_id
  
  sections   <- sections_raw |> 
    filter(!is.na(depth_m))
  
  valid_ids  <- sections$section_id
  
  # === 2. Parse contacts matrix ===
  contacts_raw <- readxl::read_xlsx(path = file_path,
                                    sheet = "transects",
                                    range = contacts_range,
                                    col_names = FALSE,
                                    .name_repair = "minimal")

  stopifnot(ncol(contacts_raw) == 4 + length(full_ids)) # four taxon id cols

  # Assign all column names before filtering
  contacts_raw <- contacts_raw |>
    set_names(c("group", "total_pts", "morphotaxon", "field_name", full_ids)) |>
    select(group, total_pts, morphotaxon, field_name, all_of(valid_ids))  # keep only valid cols

  # === 3. Tidy observations ===
  contacts <- contacts_raw |>
    select(-total_pts) |>
    mutate(across(all_of(valid_ids), as.character)) |> 
    pivot_longer(cols = -c(group, morphotaxon, field_name),
                 names_to = "section_id",
                 values_to = "contacts") |>
    mutate(contacts = readr::parse_number(contacts),  # safely parse numeric
           .after = field_name) |> 
    filter(!is.na(contacts)) |>
    left_join(sections, by = "section_id") |>
    select(ps_station_id, section_id, group, morphotaxon, field_name, contacts)
  
  # === 4. Compute total points per section ===
  section_totals <- contacts |>
    group_by(section_id) |>
    summarise(n_points = sum(contacts, na.rm = TRUE), .groups = "drop")
  
  # === 5. Add to sections ===
  sections <- sections |>
    left_join(section_totals, by = "section_id")
  
  return(list(sections = sections, observations = contacts))
}
```

```{r}
quim_lpi <- read_lpi_sheet(file_path = file.path(exp_path, "data/primary/raw/benthos/PNG_2024_lpi_fieldsheet_Quim_rev16092025.xlsx"),
                           exp_id   = "PNG_2024",
                           diver    = "Quim Garrabou",
                           section_range = "I3:PG5",
                           contacts_range = "E8:PG317")

emma_lpi <- read_lpi_sheet(file  = file.path(exp_path, "data/primary/raw/benthos/PNG_2024_lpi_fieldsheet_Emma.xlsx"),
                           exp_id = "PNG_2024",
                           diver  = "Emma Cebrian",
                           section_range = "F3:ND5",
                           contacts_range = "B8:ND352")

kat_lpi <- read_lpi_sheet(file  = file.path(exp_path, "data/primary/raw/benthos/PNG_2024_lpi_fieldsheet_Kat.xlsx"),
                          exp_id = "PNG_2024",
                          diver  = "Kat Millage",
                          section_range = "H2:Q4",
                          contacts_range = "D7:Q46")

# Combine sections
lpi_sections <- bind_rows(quim_lpi$sections,
                          emma_lpi$sections,
                          kat_lpi$sections) |> 
  rename(transect_label = station_label) |> 
  mutate(transect_label = str_extract(transect_label, "[A-Za-z]+"))

# Combine observations
lpi_contacts <- bind_rows(quim_lpi$observations,
                          emma_lpi$observations,
                          kat_lpi$observations) 
```

## QA/QC Process

### Sections

```{r}
lpi_sections |> 
  create_agent(label = "Benthos LPI Transect sections QA/QC", tbl_name = "lpi_sections") |> 
  rows_distinct(section_id,
                label = "Section IDs are unique",
                actions = action_levels(stop_at = 0.001)) |> 
  col_vals_between(n_points, 49, 51,
                   label = "50  points per section",) |> 
  interrogate()
```

### Stations

Validate station data to ensure consistency and completeness.

  - Ensure station IDs are unique
  - Confirm the correct number of points (typically 250 per station).
  - Enforce allowed values for habitat and exposure fields.
  
```{r}
# Summarize across sections into transect 

lpi_stations <- lpi_sections |> 
  group_by(ps_station_id, ps_site_id, exp_id, diver, depth_strata) |> 
  summarize(depth_m = round(mean(depth_m)),
            n_transects = n_distinct(transect_label),
            n_sections = n_distinct(section_id),
            n_points = sum(n_points),
            survey_dist_m = n_sections*10,
            .groups = "drop") |> 
  left_join(uvs_sites |> 
              distinct(ps_site_id, region, subregion, locality, habitat, exposure),
            by = "ps_site_id") |> 
  select(ps_station_id, ps_site_id, exp_id, region, subregion, locality, habitat, exposure, diver, depth_m, depth_strata, n_transects, survey_dist_m, n_points)
```

```{r}
# Station QA/QC using pointblank
station_qaqc <- lpi_stations |> 
  create_agent(label = "Benthos LPI Stations QA/QC", tbl_name = "lpi_stations") |> 
  rows_distinct(ps_station_id,
                label = "Station IDs are unique",
                actions = action_levels(stop_at = 0.001)) |>
  col_vals_equal(columns = vars(n_transects), 
                 value = 1,
                 label = "Expected 1 transects per station",
                 actions = action_levels(warn_at = 0.001)) |>
  col_vals_equal(columns = vars(n_points), 
                 value = 250,
                 label = "Expected 250 points per station",
                 actions = action_levels(warn_at = 0.001)) |> 
  interrogate()

# Display QA/QC results
station_qaqc
```


Now, lets visualize the distribution of our sampling effort and summarize it by region and subregion to inspect any potential outliers.

```{r}
#| label: fig-map
#| fig-cap: "Interactive map of LPI survey stations"

# Create spatial features
lpi_sites_sf <- uvs_sites |> 
  select(ps_site_id, region, subregion, locality, habitat, exposure, latitude, longitude) |> 
  inner_join(
    lpi_stations |> 
      group_by(ps_site_id) |> 
      summarize(diver = paste(unique(diver), collapse = "/"),
                strata = paste(unique(paste(depth_strata, " (", depth_m, "m)", sep = "")), 
                               collapse = "\n"),
                survey_dist = sum(survey_dist_m),
                n_stations = n_distinct(ps_station_id),
                .groups = "drop"),
    by = "ps_site_id") |> 
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326) 

# Create interactive map
mapview::mapview(lpi_sites_sf,
                 zcol = "exposure",
                 legend = TRUE,
                 col.regions = ps_colors("exposure"),
                 map.types = "Esri.WorldImagery",
                 layer.name = "Exposure",
                 popup = leafpop::popupTable(lpi_sites_sf, 
                                             zcol = c("ps_site_id", "strata", "diver", "survey_dist", "habitat", "exposure"))) |> 
  leafem::addMouseCoordinates() |> 
  addFullscreenControl()
```

```{r eval = T, include = T}
#| label: tbl-lpi-stations
#| tbl-cap: "Number of LPI survey stations by depth strata"

lpi_stations |> 
  group_by(region, subregion, depth_strata) |>
  summarise(n = n_distinct(ps_station_id), .groups = "drop") |> 
  pivot_wider(names_from = depth_strata, values_from = n, values_fill = 0) |> 
  mutate(Total = rowSums(across(where(is.numeric)), na.rm = TRUE)) |>
  gt(groupname_col = "region") |> 
  tab_options(table.font.size = 12,
              data_row.padding = px(5),
              table.width = pct(90),
              row_group.as_column = TRUE) |> 
  tab_source_note(source_note = "Depth strata: supershallow (< 6 m), shallow (7-14 m), deep (15-30 m)") |> 
  tab_spanner(label = "Depth Strata", 
              columns = c("deep", "shallow", "supershallow")) |> 
  cols_label(subregion = "Subregion") |>
  fmt_number(columns = where(is.numeric), decimals = 0)
```

**Summary:** We conducted bethos LPI surveys at **`r n_distinct(lpi_stations$ps_site_id)`** sites and **`r n_distinct(lpi_stations$ps_station_id)`** stations during the `r exp_id` expedition. Across **`r n_distinct(lpi_stations$region)`** regions, we surveyed a total area of **`r sum(lpi_stations$survey_dist_m)`** m of reef habitats.

### Observations

#### Merge LPI and Coral

Now, we merge the broad LPI data with the hard coral contacts from the coral specialist. In theory, divers follow the same transect line and identify taxa at the same contact points, but inevitably, factors such as currents, surge, and diver bias can lead to differences in the number of hard coral contacts recorded. The goal is to reconcile these differences while preserving the integrity of the systematic LPI sampling framework.

We accomplish this by:

  - Trusting the LPI totals - The systematic LPI method provides unbiased estimates of overall hard coral abundance
  - Leveraging coral specialist expertise - The coral diver provides high-resolution taxonomic identification
  - Proportional apportionment - We distribute the LPI hard coral total among coral species based on the proportions observed by the coral specialist

Edge case handling:

  - Normal case (both divers recorded hard coral): LPI hard coral total is apportioned among coral species based on specialist's observed proportions
  - Incomplete transect (LPI recorded hard coral, but coral specialist has no data): Hard coral remains as generic "Scleractinian" category, indicating the coral specialist was unable to complete identification for that section
  - Methodological discrepancy / Off-transect observations (coral specialist found species but LPI recorded zero hard coral): Species records are classified as off-transect observations with transect_section = "Off" and aggregated at the station level. This preserves species occurrence data while maintaining the integrity of systematic transect sampling by clearly separating opportunistic observations from quantitative abundance estimates.

This approach maintains the statistical rigor of the LPI methodology while gaining the taxonomic resolution needed for coral community analysis. The resulting dataset preserves both the overall hard coral coverage (from LPI) and the species composition (from coral specialist), providing the best of both sampling approaches.

```{r}
lpi_contacts$group[str_detect(lpi_contacts$morphotaxon, regex("\\b(Heliopora|Tubastraea|Tubastrea|Heliofungia)\\b"))] <- "Hard coral"

lpi_contacts <- lpi_contacts |> 
  left_join(lpi_stations |> 
              select(ps_station_id, exp_id, diver, depth_m)) |> 
  left_join(lpi_sections |> 
              select(section_id, transect_label, transect_section = section)) |> 
  group_by(ps_station_id, exp_id, diver, depth_m, transect_label, transect_section, group, morphotaxon, section_id) |> 
  summarize(contacts = sum(contacts), .groups = "drop")
```

```{r align}
# Explore section alignment

# Calculate LPI hard coral totals by section

lpi_sections <- lpi_sections |> 
  rename(transect_section = section) |> 
  left_join(lpi_contacts |>
              group_by(section_id) |>
              summarise(lpi_coral_pts = sum(contacts[group == "Hard coral"], na.rm = TRUE),
                        .groups       = "drop")) |> 
  mutate(lpi_pct_coral = round(100 * lpi_coral_pts / n_points, 2))

# and by station

lpi_stations <- lpi_stations |> 
  left_join(lpi_contacts |> 
              group_by(ps_station_id) |>
              summarise(lpi_coral_pts = sum(contacts[group == "Hard coral"], na.rm = TRUE),
                        .groups       = "drop")) |> 
  mutate(lpi_pct_coral = round(100 * lpi_coral_pts / n_points, 2))

total_lpi_pts <- sum(lpi_contacts$contacts)
total_lpi_coral_pts <- sum(lpi_contacts$contacts[lpi_contacts$group == "Hard coral"])
```

```{r}
coral_pts_leg1 <- read_xlsx(path = file.path(exp_path, "data/primary/raw/benthos/PS_PNG_Leg_1_AJKM_GENUS_FINAL.xlsx")) |> 
  janitor::clean_names() |> 
  rename(morphotaxon = genus) |> 
  mutate(field_name = morphotaxon,
         section = as.numeric(section)) |> 
  select(-leg, -growthform, -field_id) 

coral_pts_leg2 <- read_xlsx(path = file.path(exp_path, "data/primary/raw/benthos/PS_PNG_Leg_2_AJKM_Coral_Long_FINAL_1.xlsx")) |> 
  janitor::clean_names() |> 
  rename(field_name = species) |> 
  mutate(morphotaxon = field_name) |> 
  select(-genus)

coral_contacts <- coral_pts_leg1 |> 
  bind_rows(coral_pts_leg2) 

coral_contacts <- coral_contacts |> 
  rename(transect_label = transect_number) |> 
  filter(field_name != "No coral") |> 
  mutate(exp_id = exp_id,
         diver = "Andrew McInnis",
         site = str_extract(site, "\\d+"),
         ps_site_id = paste0("PNG_2024_uvs_", str_pad(site, 3, pad = "0")),
         survey_dist_m = str_extract(transect_length, "\\d+"),
         depth_m = as.numeric(str_extract(depth, "\\d+")),
         transect_section = case_when(section == 1 ~ "0-10",
                                      section == 2 ~ "10-20",
                                      section == 3 ~ "20-30",
                                      section == 4 ~ "30-40",
                                      section == 5 ~ "40-50"),
         depth_strata   = stratify(depth_m),
         ps_station_id  = paste(ps_site_id, station_suffix(depth_strata), sep = "_"),
         section_id     = paste0(ps_station_id, "_", transect_section)) |> 
  group_by(section_id, ps_station_id, ps_site_id, exp_id, diver,  depth_m,depth_strata, transect_label, survey_dist_m, transect_section, morphotaxon) |> 
  summarize(contacts = sum(count)) |> 
  ungroup()

coral_sections <- coral_contacts |> 
  group_by(ps_site_id, ps_station_id, section_id, depth_m, depth_strata, transect_label, transect_section) |> 
  summarise(coral_pts = sum(contacts),
            .groups = "drop")

coral_stations <- coral_sections |> 
  group_by(ps_station_id) |> 
  summarize(coral_sections = n_distinct(transect_section[coral_pts > 0]),
            coral_pts = sum(coral_pts, na.rm = T))
```

```{r}
# Station Alignment

station_alignment <- lpi_stations |> 
  full_join(coral_stations) 

station_alignment |> 
  get_dupes(ps_station_id)

station_alignment |> 
  filter(is.na(coral_pts) | is.na(lpi_coral_pts))

diffs <- station_alignment |> 
  mutate(diff = abs(coral_pts - lpi_coral_pts),
         diff_pct = 100*(lpi_coral_pts - coral_pts)/lpi_coral_pts) |> 
  arrange(desc(diff))

station_alignment |> 
  ggplot()+
  geom_point(aes(lpi_coral_pts, coral_pts))+
  geom_line(aes(lpi_coral_pts, lpi_coral_pts))

ggplot(diffs)+
  geom_histogram(aes(diff_pct), binwidth = 2)
```

```{r}
section_alignment <- lpi_sections |> 
  full_join(coral_sections |> 
              select(section_id, coral_pts),
            by = c("section_id")) |> 
  mutate(match = case_when(# Alignment
                           lpi_coral_pts > 0   & coral_pts > 0     ~ "normal",
                           lpi_coral_pts ==  0 & coral_pts  ==  0  ~ "normal",
                           # LPI data only (these become "Scleractinia")
                           lpi_coral_pts > 0   & (is.na(coral_pts) | coral_pts == 0)   ~ "lpi_only",
                           # When coral diver has pts but lpi diver does not, we turn to off transect obs
                           lpi_coral_pts == 0  & coral_pts > 0        ~ "off transect",
                           is.na(lpi_coral_pts)  & !is.na(coral_pts) & coral_pts > 0   ~ "specialist_only"),
         diff = lpi_coral_pts - coral_pts)

normal_section_ids <- section_alignment$section_id[section_alignment$match == "normal"]

section_alignment |> 
  group_by(match) |> 
  summarize(n_sections = n_distinct(section_id),
            n_pts = sum(lpi_coral_pts, na.rm = T))
```

```{r}
taxa_proportions <- coral_contacts |> 
  group_by(ps_station_id, section_id) |>
  mutate(prop_contacts = contacts / sum(contacts)) |>
  ungroup() |> 
  filter(contacts > 0) |> 
  select(ps_station_id, section_id, morphotaxon, prop_contacts)

match_normal <- section_alignment |> 
  filter(match == "normal") |> 
  mutate(diver = "Andrew McInnis") |> 
  left_join(taxa_proportions |> 
              filter(section_id %in% normal_section_ids),
            by = c("ps_station_id", "section_id"),
            suffix = c("_lpi", "_coral")) |> 
   mutate(contacts = lpi_coral_pts * prop_contacts) |> 
  filter(!is.na(ps_station_id))

match_lpi_only <- section_alignment |> 
  filter(match == "lpi_only") |> 
  mutate(morphotaxon =  "Scleractinia",
         contacts = lpi_coral_pts) |> 
  filter(!is.na(ps_station_id))

off_transect_obs <- section_alignment |> 
  filter(match == "off transect") |> 
    mutate(diver = "Andrew McInnis") |> 
  left_join(taxa_proportions,
            by = c("ps_station_id", "section_id"),
            suffix = c("_lpi", "_coral")) |> 
  mutate(contacts = 0,
         transect_section = "Off",
         section_id =  paste(ps_station_id, transect_section, sep = "_")) 

apportioned_coral_pts <- bind_rows(match_normal, match_lpi_only, off_transect_obs) |> 
  select(-lpi_coral_pts, -lpi_pct_coral, -coral_pts, -prop_contacts, -match, -diff, -n_points) |> 
  mutate(contacts = round(contacts, 3))

# We are consistnely keeping total coral points
sum(apportioned_coral_pts$contacts, na.rm = T)/total_lpi_coral_pts
```

```{r}
# Step 8: Combine with non-coral LPI data to create complete dataset
lpi_contacts_non_coral <- lpi_contacts |>
  filter(group != "Hard coral") |> 
  select(-group)

complete_lpi_data <- bind_rows(lpi_contacts_non_coral,           # All non-coral categories
                               apportioned_coral_pts |> 
                                 select(-survey_type, -method, -ps_site_id, -depth_strata) |> 
                                 mutate(functional_group = "Hard coral") # Apportioned coral species
                               ) |> 
  arrange(ps_station_id, section_id, morphotaxon) |> 
  select(section_id, everything()) |> 
  filter(contacts > 0 | transect_section == "Off")

divers_per_station <- complete_lpi_data |> 
  ungroup() |> 
  group_by(ps_station_id) |> 
  summarize(divers = paste0(unique(sort(diver)), collapse = " | ")) |> 
  ungroup()

lpi_stations <- lpi_stations |> 
  select(-diver, -lpi_pct_coral, -lpi_coral_pts) |> 
  left_join(divers_per_station) |> 
  relocate(divers, .after = locality)
```

### Taxa

```{r}
# Misspellings

lpi_observations <- complete_lpi_data |> 
  mutate(morphotaxon = str_replace(morphotaxon, "Lobophyton", "Lobophytum"),
         morphotaxon = str_replace(morphotaxon, "Lendenfeldeldia", "Lendenfeldia"),
         morphotaxon = str_replace(morphotaxon, "Lynbya", "Lyngbya"),
         morphotaxon = str_replace(morphotaxon, "Dendronephyta", "Dendronephthya"),
         morphotaxon = str_replace(morphotaxon, "Scleronephyta", "Scleronephthya"),
         morphotaxon = str_replace(morphotaxon, "Cymbastella", "Cymbastela"),
         morphotaxon = str_replace(morphotaxon, "Halyclonia", "Haliclona"),
         morphotaxon = str_replace(morphotaxon, "Asteriospicularia", "Asterospicularia") ,
         morphotaxon = str_replace(morphotaxon, "Coalocarteria", "Coelocarteria") ,
         morphotaxon = str_replace(morphotaxon, "Anthipathes", "Antipathes"),
         morphotaxon = str_replace(morphotaxon, "Elisella", "Ellisella"),
         morphotaxon = str_replace(morphotaxon, "hutschyanum", "kotschnyanum"),
         morphotaxon = str_replace(morphotaxon, "Microcinidae", "Microcionidae"),
         morphotaxon = str_replace(morphotaxon, "Darwillenidae", "Darwinellidae"),
         morphotaxon = str_replace(morphotaxon, "gemmacaea", "gemmacea"),
         morphotaxon = str_replace(morphotaxon, "acuelata", "aculeata"),
         morphotaxon = str_replace(morphotaxon, "Sandolitha", "Sandalolitha"),
         morphotaxon = str_replace(morphotaxon, "elephatotus", "elephantotus"),
         morphotaxon = str_replace(morphotaxon, "chaldicum|chalcidium", "chalcidicum"),
         morphotaxon = str_replace(morphotaxon, "transvera", "transversa"),
         morphotaxon = str_replace(morphotaxon, "amata", "ammata"),
         morphotaxon = str_replace(morphotaxon, "moniasteriata", "monasteriata"),
         morphotaxon = str_replace(morphotaxon, "nassuta", "nasuta"),
         morphotaxon = str_replace(morphotaxon, "Milipora", "Millepora"),
         morphotaxon = str_replace(morphotaxon, "Euphillia", "Euphyllia"))

lpi_observations$morphotaxon[lpi_observations$morphotaxon == "Favia matthai"] <- "Favia matthaii"
lpi_observations$morphotaxon[lpi_observations$morphotaxon == "Clavelina zobustra"] <- "Clavelina robusta"

# Summarize by mophotaxon

lpi_morphotaxa <- lpi_observations |> 
  group_by(functional_group, morphotaxon) |> 
  summarise(contacts = round(sum(contacts), 2),
            .groups = "drop") |> 
  mutate(pct_contacts = round(100 * contacts / sum(contacts), 2)) |> 
  filter(!morphotaxon %in% c("Sediment", "Turf", "Barren", "Coral rubble", "Hard coral - dead", "Hard coral - bleached", "EAM - Epilithic Algal Matrix")) |> 
  arrange(desc(contacts))

# Clean

lpi_morphotaxa <- lpi_morphotaxa |> 
  mutate(taxon_clean = morphotaxon |>
           str_remove(regex("\\blike.*", ignore_case = TRUE)) |>          # remove "like..." and everything after
           str_remove(regex("\\bsp(p)?\\.?\\b.*", ignore_case = TRUE)) |> # remove "sp.", "spp.", etc.
           str_remove(regex("\\bcf\\.|aff\\.", ignore_case = TRUE)) |>    # remove "cf.", "aff."
           str_remove_all("[\\?\\(\\)]") |>                               # remove question marks and parens
           str_squish() |> 
           str_to_sentence()) |> 
  mutate(taxon_clean = case_when(str_detect(morphotaxon, regex("sponge", ignore_case = TRUE)) | str_detect(morphotaxon, "Clathria/Dysidea") ~ "Porifera",
                                 functional_group == "Porifera" & str_detect(morphotaxon, regex("like", ignore_case = TRUE))          ~ "Porifera",
                                 morphotaxon %in% c("Red algae non identified", "Red encrusting alga non identified")                 ~ "Rhodophyta",
                                 morphotaxon %in% c("Turf", "Sediment", "Coral rubble", "Barren", "EAM - Epilithic Algal Matrix")     ~ NA_character_,
                                 morphotaxon == "Soft coral unidentified" | str_detect(morphotaxon, "Gorgonia")                       ~ "Octocorallia",
                                 morphotaxon == "Scleronephthya/Stereophthya?"                                                        ~ "Nephtheidae",
                                 morphotaxon == "Tetillidae-Cynachyrella?"                                                            ~ "Tetillidae",
                                 str_detect(morphotaxon, "Hard coral")                                                                ~ "Scleractinia",
                                 morphotaxon == "Anemone unidentified"                                                                ~ "Actiniaria",
                                 morphotaxon == "Lyngbya + Halimeda"                                                                  ~ "Lyngbya",
                                 morphotaxon == "CCA undertermined"                                                                   ~ "Corallinales",
                                 morphotaxon == "Halimeda mitja"                                                                      ~ "Halimeda",
                                 morphotaxon == "Halimeda taenicola mini"                                                             ~ "Halimeda taenicola",
                                 morphotaxon == "Hidrarian"                                                                           ~ "Hydrozoa",
                                 morphotaxon == "Clavelina zobustra"                                                                  ~ "Clavelina robusta",
                                 TRUE ~ taxon_clean),
         taxon_clean_bdc = bdc::bdc_clean_names(taxon_clean)$names_clean) |> 
  mutate(taxon_clean = coalesce(taxon_clean_bdc, taxon_clean),
         taxon_clean = case_when(morphotaxon == "Caulerpa serrulata f. spiralis" ~ "Caulerpa serrulata f. spiralis",
                                 morphotaxon == "Caulerpa racemosa var. peltata" ~ "Caulerpa racemosa var. peltata",
                                 morphotaxon == "Caulerpa chemnitzia varietat turbinata" ~ "Caulerpa chemnitzia var. turbinata",
                                 TRUE ~ taxon_clean)) |> 
  distinct(morphotaxon, taxon_clean, contacts, pct_contacts) |> 
  arrange(desc(pct_contacts))
```

```{r}
# Let's check against our Taxonomic Reference Table

benthos_taxa_lut <- tbl(bq_connection, "taxonomy.benthos") |> 
  filter(!is.na(taxon_name)) |> 
  collect()

# Create name-to-AphiaID mapping

names_to_aphiaID <- benthos_taxa_lut |> 
  select(accepted_aphia_id, taxon_name, accepted_name) |>
  pivot_longer(cols = c("taxon_name", "accepted_name"), names_to = "orig_col", values_to = "lookup_name") |>
  filter(!is.na(lookup_name)) |>
  distinct(accepted_aphia_id, lookup_name) 

lpi_morphotaxa <- lpi_morphotaxa |> 
  left_join(names_to_aphiaID, 
            by = c("taxon_clean" = "lookup_name")) 
  
lpi_morphotaxa |> 
  filter(is.na(accepted_aphia_id))
```

```{r eval = F}
new_taxa <- lpi_morphotaxa |> 
  filter(is.na(accepted_aphia_id)) |> 
  select(morphotaxon, taxon_clean, pct_contacts)

new_worms_records <- purrr::map_dfr(new_taxa$taxon_clean, 
                            ~worrms::wm_records_names(.x)) |> 
  select(taxon_clean = scientificname, aphia_id = AphiaID, rank, 
         name_status = status, accepted_name = valid_name, accepted_aphia_id = valid_AphiaID) |> 
  mutate(rank = str_to_lower(rank))

get_taxonomic_ranks <- function(id) {
  tryCatch(
    {worrms::wm_classification(id) |>
        select(rank, scientificname) |>
        pivot_wider(names_from = rank, values_from = scientificname) |>
        mutate(accepted_aphia_id = id)},
    error = function(e) {
      tibble(accepted_aphia_id = id)
    })
  }

library(furrr)

new_taxonomy_ranks <- furrr::future_map_dfr(new_worms_records$accepted_aphia_id,
                                 get_taxonomic_ranks,
                                 .options = furrr_options(seed = TRUE)) |>
  clean_names() |>
  select(accepted_aphia_id, kingdom, phylum, class, order, family, genus)

new_taxa <- new_taxa |> 
  left_join(new_worms_records) |> 
  left_join(new_taxonomy_ranks) |> 
  rename(taxon_name = taxon_clean,
         status = name_status) |> 
  select(-morphotaxon, -pct_contacts) 

new_taxa$functional_group[new_taxa$taxon_name == "Didemnidae"] <- "ascidians"
new_taxa$functional_group[new_taxa$taxon_name == "Scopalina"] <- "sponges"

# upload to BQ

bq_table_upload(bq_table("pristine-seas", "taxonomy", "benthos"),
                values = new_taxa,
                create_disposition = "CREATE_NEVER",
                write_disposition = "WRITE_APPEND")
```

```{r}
lpi_morphotaxa <- lpi_morphotaxa |> 
  left_join(benthos_taxa_lut |> 
              filter(!aphia_id %in% c(224174, 1341, 224179), !is.na(accepted_aphia_id)) |> 
              distinct(accepted_aphia_id, accepted_name, rank, functional_group, family)) 
```

```{r}
lpi_morphotaxa |> 
  mutate(rank = coalesce(rank, morphotaxon)) |> 
  group_by(rank) |> 
  summarize(n_morphotaxa = n_distinct(morphotaxon),
            n_aphia_id = n_distinct(accepted_aphia_id),
            contacts = sum(contacts),
            .groups = "drop") |> 
  arrange(desc(contacts)) |> 
  mutate(pct_contacts = round(100*contacts/sum(contacts), 2))

lpi_morphotaxa |> 
  filter(!is.na(family)) |> 
  group_by(family) |> 
  summarize(n_morphotaxa = n_distinct(morphotaxon),
            n_aphia_id = n_distinct(accepted_aphia_id),
            contacts = sum(contacts),
            .groups = "drop") |> 
  arrange(desc(contacts)) |> 
    mutate(pct_contacts = round(100*contacts/sum(contacts), 2))

lpi_morphotaxa |> 
  group_by(functional_group) |> 
  summarize(n_morphotaxq = n_distinct(morphotaxon),
            n_aphia_id = n_distinct(accepted_aphia_id),
            contacts = sum(contacts),
            .groups = "drop") |> 
  arrange(desc(contacts)) |> 
  mutate(pct_contacts = round(100*contacts/sum(contacts), 2)) # Excluding the non taxa groups e.g., barren
```

```{r}
# Combine with contacts data

clean_lpi <- lpi_observations |> 
  ungroup() |> 
  select(-functional_group) |> 
  left_join(lpi_morphotaxa |> 
              distinct(morphotaxon, accepted_name, accepted_aphia_id, rank, functional_group, family), 
            by = "morphotaxon") |> 
  mutate(functional_group = case_when(morphotaxon %in% c("Barren", "Sediment", "Coral rubble") ~ "sediment|rubble|barren", 
                                      morphotaxon == "Turf" ~ "turf",
                                      morphotaxon == "Hard coral - bleached" ~ "hard_coral",
                                      morphotaxon == "Hard coral - dead" ~ "hard_coral_dead",
                                      morphotaxon == "EAM - Epilithic Algal Matrix" ~ "eam",
                                      TRUE ~ functional_group)) 

clean_lpi <- clean_lpi |> 
  group_by(ps_station_id, exp_id, diver, depth_m, transect_label, transect_section, morphotaxon, accepted_name, accepted_aphia_id, rank, family, functional_group) |> 
  summarize(contacts = sum(contacts),
            .groups = "drop")
```

```{r}
clean_lpi |> 
  group_by(functional_group) |> 
  summarize(n_morphotaxa = n_distinct(morphotaxon),
            n_AphiaIDs   = n_distinct(accepted_aphia_id),
            contacts     = sum(contacts),
            .groups = "drop") |> 
  mutate(pct_contacts = round(100*contacts/sum(contacts), 2)) |> 
  arrange(desc(pct_contacts)) 
```

```{r}
clean_lpi |> 
  group_by(ps_station_id, transect_section) |> 
  summarize(pct_coral = sum(contacts[functional_group == "hard_coral"], na.rm = TRUE)) |> 
  left_join(lpi_contacts |> 
              group_by(ps_station_id, transect_section) |>
              summarise(lpi_coral_pts = sum(contacts[morphotaxon == "Hard coral"], na.rm = TRUE),
                        .groups       = "drop")) |> 
  mutate_if(is.numeric, round) |> 
  filter(abs(pct_coral - lpi_coral_pts) > 10)
```

```{r}
clean_lpi |> 
  get_dupes(ps_station_id, transect_label, diver, transect_section, morphotaxon)
```

## Calculate: % Cover by taxa and station

```{r}
cover_by_station_and_taxa <- clean_lpi |>
  filter(transect_section != "Off") |>

  # 1. Section-level % cover (for SD)
  group_by(ps_station_id, transect_label, transect_section) |>
  mutate(pct_cover_section = 100 * contacts / sum(contacts)) |>
  ungroup() |>

  # 2. Fill missing taxa × section combos
  group_by(diver, ps_station_id, transect_label) |>
  complete(
    nesting(transect_section),
    nesting(functional_group, morphotaxon, accepted_name, accepted_aphia_id, rank, family),
    fill = list(contacts = 0, pct_cover_section = 0)
  ) |>
  ungroup() |>

  # 3. Compute total contacts and SD across sections
  group_by(diver, ps_station_id, morphotaxon, accepted_name, accepted_aphia_id, functional_group, rank, family) |>
  summarize(
    total_contacts = sum(contacts),
    pct_cover_sd = sd(pct_cover_section),
    .groups = "drop"
  ) |>

  # 4. Compute compositional % cover
  group_by(ps_station_id) |>
  mutate(pct_cover = 100 * total_contacts / sum(total_contacts)) |>
  ungroup() |> 
  filter(total_contacts > 0)
```

```{r}
cover_by_station_and_taxa <- cover_by_station_and_taxa |> 
  left_join(lpi_stations |> 
              select(exp_id, ps_station_id, ps_site_id, region, subregion, habitat, exposure, depth_strata, depth_m),
            by = "ps_station_id") |> 
  select(ps_station_id, ps_site_id, exp_id, region, subregion, habitat, exposure, depth_strata, depth_m, 
         diver, morphotaxon, accepted_name,  accepted_aphia_id, rank, family, functional_group, total_contacts, pct_cover, pct_cover_sd)

grps_order <- c("cyanobacteria", "eam","sediment|rubble|barren", "other", "turf", "algae_encrusting",
                "algae_erect","sponges", "soft_coral","cca", "hard_coral")

cover_by_station_and_group <- cover_by_station_and_taxa |> 
  mutate(functional_group = case_when(functional_group %in% c("bryozoans","worms","echinoderms", "molluscs", "hydrozoans", "ascidians", "other_cnidarians") ~ "other",
                                      functional_group %in% c("hard_coral_dead") ~ "sediment|rubble|barren",
                                      TRUE ~ functional_group)) |> 
  group_by(region, subregion, ps_site_id, ps_station_id, depth_strata, functional_group) |> 
  summarize(pct_cover = round(sum(pct_cover),2),
            .groups = "drop") |> 
  pivot_wider(names_from = functional_group, values_from = pct_cover, values_fill = 0) |> 
  pivot_longer(cols = -c(ps_station_id, region, subregion, depth_strata, ps_site_id), names_to = "functional_group", values_to = "pct_cover") |>  
  mutate(functional_group = fct_relevel(functional_group, grps_order))
```

## Station Summary

Aggregate metrics at the station level for ecological analysis.
  
```{r}
n_morphotaxa <- cover_by_station_and_taxa |> 
  group_by(ps_station_id) |> 
  summarize(n_morphotaxa = n_distinct(morphotaxon),
            .groups = "drop") 

station_summary <- lpi_stations |> 
  left_join(n_morphotaxa) |> 
  left_join(cover_by_station_and_group |>  
              select(-region, -depth_strata, -subregion) |> 
              pivot_wider(names_from = functional_group, 
                          names_prefix = "pct_",
                          values_from = c(pct_cover), 
                          values_fill = 0) |> 
              janitor::clean_names() |> 
              rename(pct_coral = pct_hard_coral,
                     pct_rubble = pct_sediment_rubble_barren,
                     pct_cyano = pct_cyanobacteria,
                     pct_algae_encrust = pct_algae_encrusting))

station_summary |> 
  #filter(exposure != "lagoon") |> 
  group_by(region) |> 
  summarise(across(contains("pct"), mean), .groups = "drop") |> 
  mutate_if(is.numeric, round, 2)
```

## Explore 

Aggregate metrics at the station level for ecological analysis.
  
```{r}
n_morphotaxa <- cover_by_station_and_taxa |> 
  group_by(ps_station_id) |> 
  summarize(n_morphotaxa = n_distinct(morphotaxon),
            .groups = "drop") 

cover_by_station_and_group |> 
  mutate(site = str_extract(ps_site_id, "[^_]+$")) |> 
  filter(depth_strata != "supershallow") |> 
  ggplot()+
  geom_col(aes(site, pct_cover, fill = functional_group))+
  facet_grid(depth_strata~region, scales = "free")+
  scale_fill_manual(values = ps_colors("functional_groups"))+
  ggthemes::theme_fivethirtyeight()+
  labs(x = NULL, y = "Benthic composition (% of station total)",
       fill = "Functional group",
       title = "Benthic cover composition by site, region, and depth")+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor = element_blank(),
        strip.text = element_text(face = "bold"),
        legend.position = "bottom",
        legend.key.height = unit(4, "mm"),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```
  
```{r}
cover_by_station_and_group |> 
  group_by(region, subregion, depth_strata, functional_group) |> 
  summarize(pct_cover = mean(pct_cover)) |> 
  ungroup() |> 
  filter(depth_strata != "supershallow") |> 
  ggplot()+
  geom_col(aes(subregion, pct_cover, fill = functional_group))+
  facet_grid(depth_strata~region, scales = "free")+
  scale_fill_manual(values = ps_colors("functional_groups"))+
  ggthemes::theme_fivethirtyeight()+
  labs(x = NULL, y = "Benthic composition (% of station total)",
       fill = "Functional group",
       title = "Benthic cover composition by subregion, and depth")+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor = element_blank(),
        strip.text = element_text(face = "bold"),
        legend.position = "bottom",
        legend.key.height = unit(4, "mm"),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```
  
```{r}
station_summary |> 
  group_by(region, subregion) |> 
  summarize(pct_coral = mean(pct_coral)) |> 
  ggplot(aes(x = subregion, y = pct_coral, fill = (pct_coral)))+
  geom_col()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        legend.box = "horizontal")+
  facet_wrap(~region, ncol = 4, scales = "free_x")+
  labs(y = "Avg. % Cover",
       x = "",
       title = "Average % Coral Cover by Subregion",
       fill = "")+
  #scale_y_continuous(expand = expansion(mult = c(0, 0.05)))+
  ggthemes::theme_fivethirtyeight()
```

```{r}
#| label: fig-missingness-stations
#| fig-cap: "Missingness plot for station summary"
#| 
naniar::vis_miss(station_summary)
```

Examine how key ecological metrics vary across depth strata to understand vertical zonation patterns.

```{r}
#| label: fig-transects-summary
#| fig-cap: "Comparison of species richness, total count, density, and biomass across depth strata"

station_summary |> 
  select(ps_station_id, depth_strata, pct_coral, pct_cca, pct_cyano, pct_turf, pct_algae_erect, pct_rubble) |> 
  pivot_longer(cols = -c(ps_station_id, depth_strata),
               names_to = "functional_group",
               values_to = "pct_cover") |> 
  ggplot(aes(x = depth_strata, y = pct_cover, fill = depth_strata)) +
  geom_boxplot(alpha = 0.6, color = "gray40", outlier.shape = NA) +
  geom_jitter(width = 0.2, size = 1, alpha = 0.5, color = "gray30") +
  facet_wrap(~functional_group, scales = "free_y") +
  labs(x = "", 
       y = "",
       title = "**Cover by Depth Strata**",
       subtitle = "Comparison of % cover by main functional groups across depth strata") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none",
        plot.title = element_markdown(size = 18, face = "bold"),
        plot.subtitle = element_text(size = 12, face = "italic"),
        strip.text = element_text(size = 12, face = "bold"),
        panel.grid.minor = element_blank(),
        panel.grid.major.y = element_line(color = "gray90"),
        panel.grid.major.x = element_blank())+
  scale_fill_manual(values = ps_colors("depth_strata"))
```

Identify and visualize the most cover-dominant species to understand community drivers.

```{r warning = F}
#| label: fig-top-taxa
#| fig-cap: "Biomass distributions for top taxa and depth strata"
#| fig-width: 12
#| fig-height: 8

library(ggplot2)
library(dplyr)
library(ggtext)
library(RColorBrewer)

# Identify major taxa based on average % cover (after filling with zeros)

plot_df <- cover_by_station_and_taxa |> 
  select(ps_station_id, morphotaxon, accepted_name, functional_group, accepted_aphia_id, rank, pct_cover, total_contacts) |> 
  complete(ps_station_id, 
           nesting(morphotaxon, accepted_name, functional_group, accepted_aphia_id, rank),
           fill = list(pct_cover = 0,
                       total_contacts = 0))

taxa_means <- plot_df |> 
  group_by(morphotaxon) |> 
  summarise(mean_cover = mean(pct_cover, na.rm = TRUE),
            median_cover = median(pct_cover, na.rm = TRUE)) |> 
  arrange(desc(median_cover), desc(mean_cover)) 

top_taxa <- taxa_means |> 
  head(12) |> 
  pull(morphotaxon)

# Compute means and medians for each depth stratum
depth_summary <- plot_df |> 
  left_join(lpi_stations, by = "ps_station_id") |> 
  filter(morphotaxon %in% top_taxa) |> 
  group_by(morphotaxon, depth_strata) |> 
  summarise(mean_cover = mean(pct_cover, na.rm = TRUE),
    median_cover = median(pct_cover, na.rm = TRUE),
    .groups = "drop") 

# Plot

plot_df |> 
  left_join(lpi_stations) |> 
  filter(morphotaxon %in% top_taxa) |> 
  ggplot(aes(x = depth_strata, y = pct_cover, fill = morphotaxon)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5, color = "gray30") +
  geom_jitter(aes(color = morphotaxon), width = 0.2, size = 1.2, alpha = 0.6)+
  geom_text(data = depth_summary, 
            aes(label = paste0("Med: ", round(median_cover, 2)), 
                y = median_cover), 
            vjust = -0.5, size = 3, color = "black") +
  geom_text(data = depth_summary, 
            aes(label = paste0("Mean: ", round(mean_cover, 2)), 
                y = mean_cover), 
            vjust = 1.5, size = 3, color = "red")+
  facet_wrap(~ morphotaxon, scales = "free_y") +
  scale_y_continuous(trans = "log10",
                     breaks = c(0.0001, 0.001, 0.01, 0.1, 1, 10, 100, 1000),
                     labels = c("0", "0.001", "0.01", "0.1", "1", "10", "100", "1000"))+
  labs(x = "", 
       y = "% cover", 
       title = "**% Cover by Major Taxa**",
       subtitle = "Depth-stratified boxplots with jittered observations, mean (red) and median (black) labels") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none",
    plot.title = element_markdown(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 12, face = "italic"),
    strip.text = element_text(size = 12, face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_line(color = "gray90"),
    panel.grid.major.x = element_blank())+
  paletteer::scale_fill_paletteer_d("ggsci::default_igv") +
  paletteer::scale_color_paletteer_d("ggsci::default_igv")
```

## Database integration

### Pre-upload Validation

Final validation checks before uploading to the Pristine Seas Science Database.

```{r}
# Validate data completeness
validation_summary <- list(
  stations = list(
    total_records = nrow(station_summary),
    complete_records = sum(complete.cases(station_summary |> select(-locality))),
    missing_critical = sum(is.na(station_summary$ps_station_id) | 
                          is.na(station_summary$exp_id) | 
                          is.na(station_summary$region))
  ),
  contacts = list(
    total_points = sum(clean_lpi$contacts),
    total_records = nrow(clean_lpi),
    complete_records = sum(complete.cases(clean_lpi)),
    species_count = n_distinct(clean_lpi$accepted_name),
    morphotaxon_count = n_distinct(clean_lpi$morphotaxon)
  )
)

# Display validation summary
cat("📊 Data Validation Summary\n")
cat("========================\n\n")

cat("Station Summary:\n")
cat("  - Total records:", validation_summary$stations$total_records, "\n")
cat("  - Complete records:", validation_summary$stations$complete_records, "\n")
cat("  - Missing critical fields:", validation_summary$stations$missing_critical, "\n\n")

cat("Points:\n")
cat("  - Total points:", validation_summary$contacts$total_points, "\n")
cat("  - Total records:", validation_summary$contacts$total_records, "\n")
cat("  - Complete records:", validation_summary$contacts$total_records, "\n")
cat("  - Morphotaxa:", validation_summary$contacts$morphotaxon_count, "\n")
cat("  - Unique species:", validation_summary$contacts$species_count, "\n\n")
```

### Export CSV files

```{r}
cover_by_station_and_taxa <- cover_by_station_and_taxa |> 
  rename(contacts = total_contacts)

write_csv(cover_by_station_and_taxa, file.path(exp_path, "data/primary/output/benthos/lpi_cover_by_station_and_taxa.csv"))

station_summary <- station_summary |> 
  select(ps_station_id, ps_site_id, exp_id, region, subregion, locality, 
         habitat, exposure, divers, depth_m, depth_strata,
         n_transects, survey_dist_m, n_points, total_morphotaxa = n_morphotaxa, pct_coral, pct_cca, pct_cyano, everything()) 

write_csv(station_summary, file.path(exp_path, "data/primary/output/benthos/lpi_station_summary.csv"))

clean_lpi <- clean_lpi |> 
  select(ps_station_id, exp_id, diver, depth_m, transect_label, transect_section, morphotaxon, accepted_name, accepted_aphia_id, rank, family, functional_group, contacts, everything()) 

write_csv(clean_lpi, file.path(exp_path, "data/primary/output/benthos/lpi_contacts.csv"))
```

### Upload to BigQuery

Finally, Upload the validated and processed data to BigQuery, maintaining data integrity and traceability.

```{r}
bq_table_upload(bq_table("pristine-seas", "uvs", "lpi_stations"),
                values = station_summary,
                create_disposition = "CREATE_NEVER",
                write_disposition = "WRITE_APPEND")

bq_table_upload(bq_table("pristine-seas", "uvs", "lpi_contacts"),
                values = clean_lpi,
                create_disposition = "CREATE_NEVER",
                write_disposition = "WRITE_APPEND")

bq_table_upload(bq_table("pristine-seas", "uvs", "lpi_cover_by_taxa"),
                values = cover_by_station_and_taxa,
                create_disposition = "CREATE_NEVER",
                write_disposition = "WRITE_APPEND")
```
