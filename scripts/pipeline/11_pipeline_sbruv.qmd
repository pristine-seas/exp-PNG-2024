---
title: "Seabed BRUVS - Data Pipeline"
date: today
format: 
  html:
    theme: minty
    self-contained: true
    code-fold: true
    toc: true 
    toc-depth: 3
    toc-location: right
    html-table-processing: none
execute:
  fig-width: 10
---

```{r setup, message = F, warning = F, fig.width = 10, fig.height = 10, echo = F}
options(scipen = 999)
# Hook to format inline numeric expressions with comma separators:
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    # For non-numeric values, just return as character
    return(as.character(x))
  }
  # Format numbers with comma as big.mark, no scientific notation
  format(x, big.mark = ",", scientific = FALSE)
})

library(sf)
library(hms)
library(readxl)
library(janitor)
library(lubridate)
library(gt)
library(pointblank)
library(tidyverse)
library(bigrquery)
library(leaflet)
library(leaflet.extras)
library(ggtext)
library(PristineSeasR2)


ps_paths <- PristineSeasR2::get_drive_paths()

exp_id <- "PNG_2024"

exp_path <- file.path(ps_paths$expeditions, str_replace(exp_id, "_", "-"))

bigrquery::bq_auth(email = "marine.data.science@ngs.org")

bq_connection <- DBI::dbConnect(bigrquery::bigquery(), project = "pristine-seas")

exp_config <- list(exp_id      = "PNG_2024",
                   date_bounds = c(as.Date("2024-01-01"), as.Date("2024-12-31")),
                   lat_min     = -12.0, 
                   lat_max     = -1.0,  
                   lon_min     = 140.0, 
                   lon_max     = 155.0) 
```

This documentation outlines the end-to-end pipeline for processing seabed BRUVS data collected during Pristine Seas expeditions. The pipeline ingests raw field data, standardizes formats, performs taxonomy lookups, applies quality assurance/quality control (QA/QC), computes station-level summaries, and loads the clean data into the Pristine Seas Science Database in BigQuery.

## Data ingestion

### Deployments (Stations)

```{r}
sbruvs_raw <- read_xlsx(file.path(exp_path, "data/primary/raw/bruvs", "PNG_2024_bruvs_fieldbook.xlsx")) |> 
  janitor::clean_names() 

stations <- sbruvs_raw |> 
  rename(time = time_in,
         left_cam = cam_l,
         right_cam = cam_r,
         ps_site_id = ps_station_id,
         field_notes = notes,
         rig_id = rig) |> 
  mutate(exp_id = exp_id, 
         ps_site_id  =  str_replace(ps_site_id, "(\\d+)$", ~ str_pad(.x, 3, pad = "0")),
         ps_station_id = paste0(ps_site_id, "_", paste0(round(depth_m), "m")),
         date           = lubridate::ymd(date),
         time           = hms::as_hms(time),
         video_quality = NA,
         annotation_partner = "USP",
         analysis_status = "pending",
         partner_code = NA_character_,
         analysis_notes = NA_character_,
         ) |> 
  select(ps_station_id, ps_site_id, exp_id, region, subregion, locality, date, time, 
         latitude, longitude, depth_m, habitat, exposure,  bottom_type, 
         rig_id, left_cam, right_cam, team_lead, video_quality, highlights, field_notes, annotation_partner, analysis_status, partner_code, analysis_notes) 
```

## QAQC

### Data overview

```{r}
#| label: tbl-summary-stats
#| tbl-cap: "sBRUVS Pipeline Summary Statistics"
#| 
stations |> 
  summarize(n_deployments = as.character(n()),
            date_range = paste(min(date, na.rm = TRUE), "to", max(date, na.rm = TRUE)),
            regions = paste(sort(unique(region)), collapse = ", "),
            subregions = paste(sort(unique(subregion)), collapse = ", "),
            depth_range_m = paste(min(depth_m, na.rm = TRUE), "-", max(depth_m, na.rm = TRUE))) |> 
  pivot_longer(everything(), names_to = "variable", values_to = "value") 
```

```{r map}
# Interactive visual map

stations_sf <- stations |>
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) |>
  distinct(ps_site_id, region, subregion, locality, habitat, exposure, depth_m, geometry)

mapview::mapview(stations_sf,
                 zcol = "depth_m",
                 legend = TRUE,
                 map.types = "Esri.WorldImagery",
                 layer.name = "depth_m",
                 popup = leafpop::popupTable(stations_sf, 
                                             zcol = c("ps_site_id", "region", "subregion", "locality", "habitat",  "exposure", "depth_m"))) |> 
  leafem::addMouseCoordinates() |> 
  leaflet.extras::addFullscreenControl()
```

### Stations

```{r}
regions_lookup_table <- tbl(bq_connection, "uvs.blt_stations") |> 
  filter(exp_id == "PNG_2024") |> 
  collect() |> 
  distinct(region, subregion)

valid_regions <- unique(regions_lookup_table$region)

valid_subregions <- unique(regions_lookup_table$subregion)

stations |> 
  create_agent(label = "Seabed BRUVS stations QA/QC", tbl_name = "stations") |> 
  rows_distinct(ps_site_id,
                label = "Unique site IDs",
                actions = action_levels(stop_at = 0.001)) |> 
  # Enforce non-missing values for critical columns
  rows_complete(columns = vars(ps_site_id, latitude, longitude, date),
                label = "Complete rows for key fields",
                actions = action_levels(warn_at = 0.01, stop_at = 0.05)) |> 
  # Region validation against lookup table
  col_vals_in_set(columns = vars(region),
                  set = valid_regions,
                  label = "Region in lookup table",
                  actions = action_levels(warn_at = 0.01, stop_at = 0.05)) |>
  col_vals_in_set(columns = vars(subregion), 
                  set = valid_subregions,
                  label = "Subregion in lookup table",
                  actions = action_levels(warn_at = 0.01, stop_at = 0.05)) |>
  # Habitat and exposure validation against allowed vocab
  col_vals_in_set(columns = vars(habitat),
                  set = allowed_vocab$uvs_habitats,
                  label = "Valid habitat values",
                  actions = action_levels(stop_at = 0.1)) |>
  col_vals_in_set(columns = vars(exposure),
                  set = allowed_vocab$exposure,
                  label = "Valid exposure values",
                  actions = action_levels(stop_at = 0.1)) |>
  # Critical NAs
  col_vals_not_null(columns = vars(latitude, longitude),
                    label = "Coordinates are not missing",
                    actions = action_levels(warn_at = 0.01, stop_at = 0.05)) |>
  col_vals_not_null(columns = vars(date),
                    label = "Date is not missing", 
                    actions = action_levels(warn_at = 0.01, stop_at = 0.05)) |> 
  # Geographic bounds validation
  col_vals_between(columns = vars(latitude),
                   left = exp_config$lat_min,
                   right = exp_config$lat_max,
                   label = "Latitude within bounds",
                   actions = action_levels(warn_at = 0.01, stop_at = 0.05)) |>
  col_vals_between(columns = vars(longitude),
                   left = exp_config$lon_min, 
                   right = exp_config$lon_max,
                   label = "Longitude within bounds",
                   actions = action_levels(warn_at = 0.01, stop_at = 0.05)) |> 
  # Date within expedition range
  col_vals_between(columns = vars(date),
                   left = exp_config$date_bounds[1],
                   right = exp_config$date_bounds[2], 
                   label = "Date within expedition period",
                   actions = action_levels(warn_at = 0.01, stop_at = 0.05)) |> 
  interrogate()
```

### Taxa

## Ecological Metrics

## Explore and Visualize Data

## Database integration

```{r}
bq_table_upload(x = bq_table("pristine-seas", "sbruv", "stations"),
                values = stations,
                create_disposition = "CREATE_NEVER",
                write_disposition = "WRITE_TRUNCATE")
```

```{r}
write_csv(stations, file.path(exp_path,    "data/primary/output/sbruv",  "SLB_2024_sbruvs_stations_clean.csv"))
```


